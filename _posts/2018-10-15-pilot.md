---
title:  "pilot"
date:   2018-10-15 21:37:00
---

So no one is probably going to be reading these, so I guess I'll keep this as a diary of sorts on the problems that we solved. 

The contest we attempted was the 2017-18 ACM-ICPC NCPC. Most people in my friendlist solved around 7-8 questions, with 7 problems common and the 8th problem solved being different. In total, 9 unique problems were solved in contest. 

### **Problem J**

If l is equal to r, print out "EVEN 2\*l" otherwise, just print out "ODD 2\*max(l,r)". If both l and r are 0, then print out "Not a moose".

Time Complexity: O(1)

### **Problem B**

The solution is to iterate over runners assuming they go first, then find the next three fastest runners. Then we just take the minimum over these combinations.

Time Complexity: O(n\*n\*log(n))

### **Problem K** 

Here, we perform a binary search on the speed of the slowest boat. We always try to put the least strength of kayakers whenever possible. 

Time Complexity: O(log2(MAXC)\*n\*6) 

Note: If we change the number of kayakers in a kayak from 2 to k and type of kayakers from 3 to l, the answer should be O(log2(MAXC)\*n\*(k+l-1)C(k))

### **Problem G**

I solved it using a multisets corresponding to the number of problems solved and storing penalty involved. Then you just need the number of teams solving more problems than the first team, which you can easily store in an array counting the number of teams to solve i problems, plus the number of teams with a lower penalty, which can be found from the corresponding multiset.

Time Complexity: O(m\*log(n)), since each question solved by someone other than the 1st team takes log(n) to process when it is read, then once more when the 1st team also solves that many questions, thus giving O(m\*log(n))

### **Problem E**

Process nodes in decreasing depth. Basically, Once we've processed all nodes of depth d\_i, we've reached all possible nodes with depth <= d\_i and now must move upwards and explore nodes of > d\_i.

Time Complexity: O(h\*w\*log(h\*w)). This is a slight modification of Djistkra's.

### **Problem D**

This problem can be modelled as a graph (V,E) where two number have an edge between them if their binary representation has one digit flipped. Then, we just need to find the number which is at a maximum distance from all the given nodes, which we can find with a simple BFS.

Time Complexity: Interestingly enough, this is O(k\*2^k) and does not depend on k.

### **Problem I**

This problem simply asks if a cycle exists in the dependency graph, and if it does exist, find the elements of the shortest cycle. Simply running a BFS from each node will find the shortest cycle it is a part of.

Time Complexity: O(n\*(n+m)), because we run a BFS for each node.

### **Problem C**

So this problem seems hard initially, but you can prove that removal of each card only influences 6 cards around it. The case when there are two or more cards adjacent with the same angle is the only issue, but you can discard (hah pun) those cases when you realise their uniqueness due to that color was 0 anyways.

Time Complexity: O(n\*log(n)), for sorting.

## **Problem A**

 
